# **DataStructure**

[**排序**](#排序)

[**树**](#树)


## **排序**

<b><details><summary>冒泡排序</summary></b>
</details>

<b><details><summary>选择排序</summary></b>

</details>

<b><details><summary>插入排序</summary></b>

</details>

<b><details><summary>希尔排序</summary></b>

</details>

<b><details><summary>堆排序</summary></b>

</details>

<b><details><summary>快速排序</summary></b>

</details>

<b><details><summary>归并排序</summary></b>

</details>

## **树**

<b><details><summary>二叉树</summary></b>
- **性质**
    - 非空二叉树第 `i` 层最多 `2(i-1)` 个结点 `（i >= 1）`
    - 深度为 `k` 的二叉树最多 `2k - 1` 个结点 `（k >= 1）`
    - 度为 `0` 的结点数为 `n0`，度为 `2` 的结点数为 `n2`，则 `n0 = n2 + 1`
    - 有 `n` 个结点的完全二叉树深度 `k = ⌊ log2(n) ⌋ + 1`
    - 对于含 `n` 个结点的完全二叉树中编号为 `i （1 <= i <= n）` 的结点
      - 若 `i = 1`，为根，否则双亲为 `⌊ i / 2 ⌋`
      - 若 `2i > n`，则 `i` 结点没有左孩子，否则孩子编号为 `2i`
      - 若 `2i + 1 > n`，则 `i` 结点没有右孩子，否则孩子编号为 `2i + 1`

</details>

<b><details><summary>完全二叉树（堆）</summary></b>
- **性质**
    - 大根堆：根 >= 左 && 根 >= 右
    - 小根堆：根 <= 左 && 根 <= 右

</details>


<b><details><summary>二叉搜索树</summary></b>
- **性质**
    - 左 < 根 < 右
    - 中序输出有序\
- **插入**
    - 树为空，直接插入
    - 树不为空，根据搜索二叉树性质找到插入位置，插入新节点
-  **删除**
    - 首先在树中查找待删除元素 `A` ，如果不存在，则结束删除，否则继续
    - 查找到的节点分为下面情况
        - 要删除的节点 `A` 无孩子节点，直接删除，并使 `A` 节点的双亲对应的指针指向 `NULL`
        - 要删除的节点 `A` 只有左孩子节点，删除该节点，且使 `A` 节点的双亲指向 `A` 节点的左孩子
        - 要删除的节点 `A` 只有右孩子节点，删除该节点，且使 `A` 节点的双亲指向 `A` 节点的有孩子
        - 要删除的节点 `A` 有左、右孩子节点，一般采取替换的方式，从 `A` 节点的右子树中找一个最小的(或者从左子树中找到一个最大的)节点 `B`，用 `B` 的值替换待删除节点，再删除 `B`

</details>

<b><details><summary>`AVL` 树</summary></b>
- **性质**
  - 平衡因子（每个节点左右子树差值的绝对值）的值不超过`1` ，`|` 左子树树高 `-` 右子树树高 `|`  <= `1`
  - 平衡二叉树必定是二叉搜索树，反之则不一定

- **插入**
    - 按照搜索二叉树的插入方式，找到待插入位置
    - 调节节点的平衡因子，如果失去平衡，则调整

- **调整**
    - `LL` 新插入的节点在失去平衡的节点的较高的左子树左侧，使用 `右单旋失去平衡节点` 解决问题
    - `RR` 新插入的节点在失去平衡的节点的较高的右子树右侧，使用 `左单旋失去平衡节点` 解决问题
    - `LR` 新插入的节点在失去平衡的节点的较高的左子树的右子树上，使用 `左单旋左子树再右单旋失去平衡节点` 解决问题
    - `RL` 新插入的节点在失去平衡的节点的较高的右子树的左子树上，使用 `右单旋右子树再左单旋失去平衡节点` 解决问题

    | 插入方式 | 描述                                              | 旋转方式     |
| -------- | :------------------------------------------------ | ------------ |
    | `LL`     | 在 `a` 的左子树根节点的左子树上插入节点而破坏平衡 | 右单旋       |
| `RR`     | 在 `a` 的右子树根节点的右子树上插入节点而破坏平衡 | 左单旋       |
    | `LR`     | 在 `a` 的左子树根节点的右子树上插入节点而破坏平衡 | 先左旋后右旋 |
| `RL`     | 在 `a` 的右子树根节点的左子树上插入节点而破坏平衡 | 先右旋后左旋 |

</details>

<b><details><summary>红黑树</summary></b>
- **性质**
  - 节点是红色或黑色
  - 根是黑色
  - 所有叶子都是黑色（叶子是 NIL 节点）
  - 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）（新增节点的父节点必须相同）
  - 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。（新增节点必须为红）

</details>

<b><details><summary>`B` 树</summary></b>

- **性质**
    - 根节点至少有两个孩子，至少有一个关键字（孩子可以看成指针，关键字可以看成 `Data`）
    - 每个非根节点至少有 `M/2(上取整)` 个孩子,至多有 `M` 个孩子
    - 每个非根节点至少有 `M/2(上取整)-1` 个关键字,至多有 `M-1` 个关键字，并且以升序排列
    - 每个结点中的关键字都按照从小到大的顺序排列，`key[i]` 和 `key[i+1]` 之间的孩子节点的值介于 `key[i]、key[i+1]`之间
    - 所有叶子结点都位于同一层，或者说根结点到每个叶子结点的长度都相同
- **插入**

    插入操作是指插入一条记录，即`（key, value）`的键值对。如果 `B` 树中已存在需要插入的键值对，则用需要插入的`value` 替换旧的 `value` 。若 `B` 树不存在这个 `key` ，则一定是在叶子结点中进行插入操作

    1. 根据要插入的 `key` 的值，找到叶子结点并插入

    2. 判断当前结点 `key` 的个数是否小于等于 `M-1` ，若满足则结束，否则进行第 `3` 步

    3. 以结点中间的 `key` 为中心分裂成左右两部分，然后将这个中间的 `key` 插入到父结点中，这个 `key` 的左子树指向分裂后的左半部分，这个 `key` 的右子支指向分裂后的右半部分，然后将当前结点指向父结点，继续进行第 `3` 步
- **删除**

    删除操作是指，根据 `key` 删除记录，如果 `B` 树中的记录中不存对应 `key` 的记录，则删除失败

    1. 如果当前需要删除的 `key` 位于非叶子结点上，则用后继 `key`（这里的后继 `key` 均指后继记录的意思）覆盖要删除的 `key` ，然后在后继 `key` 所在的子支中删除该后继 `key` 。此时后继 `key` 一定位于叶子结点上，这个过程和二叉搜索树删除结点的方式类似。删除这个记录后执行第 `2` 步

    2. 该结点 `key` 个数大于等于 `M/2(上取整)-1` ，结束删除操作，否则执行第 `3` 步

    3. 如果兄弟结点 `key` 个数大于 `M/2(上取整)-1` ，则父结点中的 `key` 下移到该结点，兄弟结点中的一个 `key` 上移，删除操作结束。否则，将父结点中的 `key` 下移与当前结点及它的兄弟结点中的 `key` 合并，形成一个新的结点。原父结点中的`key` 的两个孩子指针就变成了一个孩子指针，指向这个新结点。然后当前结点的指针指向父结点，重复上第 `2` 步。有些结点它可能既有左兄弟，又有右兄弟，那么我们任意选择一个兄弟结点进行操作即可

</details>

<b><details><summary>`B+` 树</summary></b>
- **性质**
    - `B+` 树是 `B` 树的变形，也是一种多路搜索树，其基本定义与 `B` 树相同，除此之外 `B+` 树还有以下的要求：
    - `B+` 树包含 `2` 种类型的结点：内部结点（也称索引结点）和叶子结点。根结点本身即可以是内部结点，也可以是叶子结点。根结点的关键字个数最少可以只有 `1` 个
    - `B+` 树与 `B` 树最大的不同是内部结点不保存数据，只用于索引，所有数据（或者说记录）都保存在叶子结点中
    - `M` 阶 `B+` 树表示了内部结点最多有 `M-1` 个关键字（或者说内部结点最多有 `M` 个子树），阶数 `M` 同时限制了叶子结点最多存储 `M-1` 个记录
    - 内部结点中的 `key` 都按照从小到大的顺序排列，对于内部结点中的一个 `key` ，左树中的所有 `key` 都小于它，右子树中的 `key` 都大于等于它。叶子结点中的记录也按照 `key` 的大小排列
    - 每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接
- **插入**

    1. 若为空树，创建一个叶子结点，然后将记录插入其中，此时这个叶子结点也是根结点，插入操作结束

    2. 针对叶子类型结点：根据 `key` 值找到叶子结点，向这个叶子结点插入记录。插入后，若当前结点 `key` 的个数小于等于 `M-1` ，则插入结束。否则将这个叶子结点分裂成左右两个叶子结点，左叶子结点包含前 `M/2` 个记录，右结点包含剩下的记录，将第 `M/2+1` 个记录的 `key` 进位到父结点中（父结点一定是索引类型结点），进位到父结点的 `key` 左孩子指针向左结点，右孩子指针向右结点。将当前结点的指针指向父结点，然后执行第 `3` 步

    3. 针对索引类型结点：若当前结点 `key` 的个数小于等于 `M-1` ，则插入结束。否则，将这个索引类型结点分裂成两个索引结点，左索引结点包含前 `(M-1)/2` 个 `key` ，右结点包含 `M-(M-1)/2` 个 `key` ，将第 `M/2` 个 `key` 进位到父结点中，进位到父结点的 `key` 左孩子指向左结点, 进位到父结点的 `key` 右孩子指向右结点。将当前结点的指针指向父结点，然后重复第 `3` 步
- **删除**

    如果叶子结点中没有相应的 `key` ，则删除失败。否则执行下面的步骤

    1. 删除叶子结点中对应的 `key` 。删除后若结点的 `key` 的个数大于等于 `Math.ceil(M-1)/2 – 1` ，删除操作结束,否则执行第 `2` 步

    2. 若兄弟结点 `key` 有富余 `（大于M/2(上取整) – 1）` ，向兄弟结点借一个记录，同时用借到的 `key` 替换父结（指当前结点和兄弟结点共同的父结点）点中的 `key` ，删除结束。否则执行第 `3` 步

    3. 若兄弟结点中没有富余的 `key` ，则当前结点和兄弟结点合并成一个新的叶子结点，并删除父结点中的 `key`（父结点中的这个 `key` 两边的孩子指针就变成了一个指针，正好指向这个新的叶子结点），将当前结点指向父结点（必为索引结点），执行第 `4` 步（第 `4` 步以后的操作和 `B` 树就完全一样了，主要是为了更新索引结点）

    4. 若索引结点的 `key` 的个数大于等于 `M/2(上取整) – 1` ，则删除操作结束。否则执行第 `5` 步

    5. 若兄弟结点有富余，父结点 `key` 下移，兄弟结点 `key` 上移，删除结束。否则执行第 `6` 步

    6. 当前结点和兄弟结点及父结点下移 `key` 合并成一个新的结点。将当前结点指向父结点，重复第 `4` 步

    注意，通过 `B+` 树的删除操作后，索引结点中存在的 `key` ，不一定在叶子结点中存在对应的记录

</details>

<b><details><summary>`B*` 树</summary></b>
- **性质**
    - `B*` 树是 `B+` 树的变形，在 `B+` 树的非根和非叶子节点再增加指向兄弟节点的指针。

</details>